/** Modal Reactor Test. Tests cycling through modes. */
target C {
  timeout: 2 sec
}

preamble {=
  void print_logical_and_physical_time();
=}
reactor CounterCycle {
  input next: bool
  output next_sync: bool
  output count: int

  initial mode One {
    reaction(next) -> count, reset(Two), next_sync {=
      lf_set(count, 1);
      lf_set(next_sync, next);
      lf_set_mode(Two);
    =}
  }

  mode Two {
    reaction(next) -> count, reset(Three), next_sync {=
      lf_set(count, 2);
      lf_set(next_sync, next);
      lf_set_mode(Three);
    =}
  }

  mode Three {
    reaction(next) -> count, reset(One), next_sync {=
      lf_set(count, 3);
      lf_set(next_sync, next);
      lf_set_mode(One);
    =}
  }
}

reactor CounterCycle_replica {
  input next: bool
  output count: int

  input read_trigger: bool
  

  initial mode One {
    reaction(next) -> count, reset(Two) {=
      lf_set(count, 1);
      lf_set_mode(Two);
    =}

    reaction(read_trigger) -> count {=
      lf_set(count, 1);
    =}
  }

  mode Two {
    reaction(next) -> count, reset(Three) {=
      lf_set(count, 2);
      lf_set_mode(Three);
    =}

    reaction(read_trigger) -> count {=
      lf_set(count, 2);
    =}
  }

  mode Three {
    reaction(next) -> count, reset(One) {=
      lf_set(count, 3);
      lf_set_mode(One);
    =}

    reaction(read_trigger) -> count {=
      lf_set(count, 3);
    =}
  }
}

reactor Analyzer {
  input clk: bool
  input counter_out: int
  input replica_out: int
  output count: int

  state expected_value: int = 1
  
  reaction(clk) counter_out, replica_out {=
    printf("%d\n", counter_out->value);

    if (!counter_out->is_present) {
      printf("ERROR: Missing mode change.\n");
      exit(1);
    } else if (counter_out->value != self->expected_value) {
      printf("ERROR: Wrong mode.\n");
      exit(2);
    }

    if (self->expected_value == 3) {
      self->expected_value = 1;
    } else {
      self->expected_value++;
    }
  =}
}

reactor User {
  input read_val: int;
  output write: bool;
  output read_trigger: bool;
  output analyzer_clk: bool;
  timer stepper(0, 250 msec)
  timer read_timmer(0, 250 msec)

  state write_state: int = 1
  state replica_state: int;

  // write the value i.e. have the state to update.
  reaction(stepper) -> write, analyzer_clk {=
    lf_set(write, true);
    lf_set(analyzer_clk, true);
    printf("write state: %d.\n", self->write_state);
    // print_logical_and_physical_time();
    if (self->write_state == 3) {
      self->write_state = 1;
    } else {
      self->write_state++;
    }
  =}

  // read the value
  reaction(read_timmer) -> read_trigger {=
    lf_set(read_trigger, true);
    
  =}
  
  reaction(read_val) {=
    self->replica_state = read_val->value;
    printf("Read Value: %d.\n", self->replica_state);
    // print_logical_and_physical_time();
  =}
}
main reactor {
  preamble {=
  void print_logical_and_physical_time() {
    
    // interval_t t = lf_time_logical_elapsed();
    // interval_t T = lf_time_physical_elapsed();
    // printf(
    //     "Elapsed logical time: %ld, physical time: %ld, lag: %ld\n",
    //     t, T, T-t
    // );
    }
  =}
  // timer stepper(0, 250 msec)
  counter = new CounterCycle()

  replica = new CounterCycle_replica()
  
  analyzer = new Analyzer()

  user = new User()

  state expected_value: int = 1

  // Write
  

  user.write -> counter.next;
  counter.next_sync -> replica.next;

  // Check
  // user.analyzer_clk -> analyzer.clk;
  // counter.count -> analyzer.counter_out;
  // replica.count -> analyzer.replica_out;
  
  // read
  user.read_trigger -> replica.read_trigger;
  replica.count -> user.read_val
  
}
